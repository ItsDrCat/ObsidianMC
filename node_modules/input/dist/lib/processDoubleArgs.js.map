{"version":3,"sources":["../../src/lib/processDoubleArgs.js"],"names":[],"mappings":";;;;;;;;;;kBAawB;;AAbxB;;AACA;;;;;;;;;;;;;;;;AAYe,SAAS,iBAAT,CAA2B,IAA3B,EAAiC,YAAjC,EAA+C,IAA/C,EAAqD;AAClE,MAAI,gBAAJ,CADkE;AAElE,MAAI,QAAQ,YAAR;;;AAF8D,UAK1D,KAAK,MAAL;AACN,SAAK,CAAL;AAAQ,YAAR;;AADF,SAGO,CAAL;AAAQ;AACN,YAAM,MAAM,KAAK,CAAL,CAAN,CADA;;AAGN,YAAI,sBAAS,GAAT,CAAJ,EAAmB;AACjB,kBAAQ,GAAR,CADiB;AAEjB,oBAAU,EAAV,CAFiB;SAAnB,MAIK,IAAI,2BAAc,GAAd,CAAJ,EAAwB,UAAU,GAAV,CAAxB,KACA;AACH,gBAAM,IAAI,SAAJ,wFACgF,8EADhF,CAAN,CADG;SADA;;AAOL,cAdM;OAAR;;AAHF,SAoBO,CAAL;AAAQ;AACN,gBAAQ,KAAK,CAAL,CAAR,CADM;AAEN,kBAAU,KAAK,CAAL,CAAV,CAFM;;AAIN,YAAI,CAAC,2BAAc,OAAd,CAAD,EAAyB;AAC3B,gBAAM,IAAI,SAAJ,gFACwE,uEADxE,CAAN,CAD2B;SAA7B;;AAMA,cAVM;OAAR;;AApBF;AAiCW,YAAM,IAAI,SAAJ,6CAAwD,KAAK,MAAL,CAA9D,CAAT;AAjCF;;;AALkE,MA0C9D,QAAQ,OAAR,KAAoB,SAApB,EAA+B;AACjC,QAAI,sBAAS,QAAQ,OAAR,CAAb,EAA+B,QAAQ,OAAR,GAAkB,OAAO,QAAQ,OAAR,CAAzB,CAA/B,KACK,IAAI,sBAAS,QAAQ,OAAR,IAAmB,CAAC,WAAW,IAAX,CAAgB,QAAQ,OAAR,CAAjB,CAAhC,EAAoE;AACvE,YAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN,CADuE;KAApE;GAFP;;AAOA,SAAO,+BAAgB;AACrB,gBADqB,EACd,UADc;AAErB,cAAU,QAAQ,QAAR;AACV,qBAAiB,QAAQ,OAAR;GAHZ,CAAP,CAjDkE;CAArD","file":"processDoubleArgs.js","sourcesContent":["import { isString, isPlainObject, isNumber } from 'lodash';\nimport finaliseOptions from './finaliseOptions';\n\n/**\n * Processes any arguments object that fulfills the double-argument signature\n * used by `text()`, `password()`, `confirm()`, etc:\n *\n * `([String: label], [PlainObject: options])`\n *\n * (NB. that is the expected signature of the passed-in `args` object,\n * not of this function itself.)\n */\n\nexport default function processDoubleArgs(args, defaultLabel, type) {\n  let options;\n  let label = defaultLabel;\n\n  // extract and validate args\n  switch (args.length) {\n    case 0: break;\n\n    case 1: {\n      const arg = args[0];\n\n      if (isString(arg)) {\n        label = arg;\n        options = {};\n      }\n      else if (isPlainObject(arg)) options = arg;\n      else {\n        throw new TypeError(\n          `input: Expected single argument to be a label or options object, but got: ${typeof arg}\n        `);\n      }\n\n      break;\n    }\n\n    case 2: {\n      label = args[0];\n      options = args[1];\n\n      if (!isPlainObject(options)) {\n        throw new TypeError(\n          `input: Expected second argument to be an options object, but got: ${typeof options}`\n        );\n      }\n\n      break;\n    }\n\n    default: throw new TypeError(`input: Expected 0-2 arguments, but got ${args.length}`);\n  }\n\n  // ensure options.default is valid if set\n  if (options.default !== undefined) {\n    if (isNumber(options.default)) options.default = String(options.default);\n    else if (isString(options.default && !/[^\\n\\r]*/.test(options.default))) {\n      throw new Error('input: options.default contained invalid characters');\n    }\n  }\n\n  return finaliseOptions({\n    label, type,\n    validate: options.validate,\n    inquirerDefault: options.default,\n  });\n}\n"]}